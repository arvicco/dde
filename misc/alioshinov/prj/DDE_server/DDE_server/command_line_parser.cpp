#include "command_line_parser.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::CommandLineParser(int argc,char *argv[])
//  Назначение:    Конструктор класса с параметрами(выполняет разбор параметров командной строки)
//  Вход:          параметры функции main
//  Выход:         нет
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
CommandLineParser::CommandLineParser(int argc,char *argv[])
{
	string str;
	size_t found;
	service = "excel";
	col_deliver = ";";
	row_deliver = "\n";
	data_deliver = "";
	topit_deliver = "";

	if (argc == 1)	// Если параметров не было, то используем значения по умолчанию
	{
		status = CML_OK;
		return;
	}

	for (int i = 1; i < argc; i++)	// Цикл перебора параметров
	{
		str = argv[i];

		if (!str.compare("-h"))	// Если встретился параметр -h, то выводим помощь
		{
			status = CML_HELP;
			return;
		}

		if (!str.compare("-s"))	// если встретился параметр -s, то следующий
		{						// за ним параметр есть имя сервиса
			i++;
			service = argv[i];
			while (1)	// Заменяем символы "\t" на 1 символ '\t' (если встречаются в имени)
			{
				found = service.find("\\t");
				if (found == string::npos) break;
				service.replace(found,2,1,'\t');
			}
			while (1)	// Заменяем символы "\n" на 1 символ '\n' (если встречаются в имени)
			{
				found = service.find("\\n");
				if (found == string::npos) break;
				service.replace(found,2,1,'\n');
			}
			continue;
		}

		if (!str.compare("-f"))	// если встретился параметр -f, то следующий
		{						// за ним параметр есть разделитель столбцов
			i++;
			col_deliver = argv[i];
			while (1)	// Заменяем символы "\t" на 1 символ '\t' (если встречаются в имени)
			{
				found = col_deliver.find("\\t");
				if (found == string::npos) break;
				col_deliver.replace(found,2,1,'\t');
			}
			while (1)	// Заменяем символы "\n" на 1 символ '\n' (если встречаются в имени)
			{
				found = col_deliver.find("\\n");
				if (found == string::npos) break;
				col_deliver.replace(found,2,1,'\n');
			}
			continue;
		}

		if (!str.compare("-n"))	// если встретился параметр -n, то следующий
		{						// за ним параметр есть разделитель строк
			i++;
			row_deliver = argv[i];
			while (1)	// Заменяем символы "\t" на 1 символ '\t' (если встречаются в имени)
			{
				found = row_deliver.find("\\t");
				if (found == string::npos) break;
				row_deliver.replace(found,2,1,'\t');
			}
			while (1)	// Заменяем символы "\n" на 1 символ '\n' (если встречаются в имени)
			{
				found = row_deliver.find("\\n");
				if (found == string::npos) break;
				row_deliver.replace(found,2,1,'\n');
			}
			continue;
		}

		if (!str.compare("-d"))	// если встретился параметр -d, то следующий
		{						// за ним параметр есть разделитель блоков данных
			i++;
			data_deliver = argv[i];
			while (1)	// Заменяем символы "\t" на 1 символ '\t' (если встречаются в имени)
			{
				found = data_deliver.find("\\t");
				if (found == string::npos) break;
				data_deliver.replace(found,2,1,'\t');
			}
			while (1)	// Заменяем символы "\n" на 1 символ '\n' (если встречаются в имени)
			{
				found = data_deliver.find("\\n");
				if (found == string::npos) break;
				data_deliver.replace(found,2,1,'\n');
			}
			continue;
		}

		if (!str.compare("-t"))	// если встретился параметр -t, то следующий
		{						// за ним параметр есть разделитель данных разных таблиц
			i++;
			topit_deliver = argv[i];
			while (1)	// Заменяем символы "\t" на 1 символ '\t' (если встречаются в имени)
			{
				found = topit_deliver.find("\\t");
				if (found == string::npos) break;
				topit_deliver.replace(found,2,1,'\t');
			}
			while (1)	// Заменяем символы "\n" на 1 символ '\n' (если встречаются в имени)
			{
				found = topit_deliver.find("\\n");
				if (found == string::npos) break;
				topit_deliver.replace(found,2,1,'\n');
			}
			continue;
		}

		status = CML_HELP;	// Если встретился неизвестный параметр, то выдаем помощь
		return;
	}
	status = CML_OK;	// В случае успеха устанавливаем положительный статус
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::CommandLineParser()
//  Назначение:    Конструктор класса без параметров(инициализирует поля значениями по умолчанию)
//  Вход:          нет
//  Выход:         нет
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
CommandLineParser::CommandLineParser()
{
	service = "excel";
	col_deliver = ";";
	row_deliver = "\n";
	data_deliver = "";
	topit_deliver = "";
	status = CML_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::GetServiceName()
//  Назначение:    Возвращает имя сервиса
//  Вход:          нет
//  Выход:         имя сервиса
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
string CommandLineParser::GetServiceName() {return service;}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::GetColDeliver()
//  Назначение:    Возвращает разделитель колонок таблицы
//  Вход:          нет
//  Выход:         разделитель колонок таблицы
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
string CommandLineParser::GetColDeliver() {return col_deliver;}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::GetRowDeliver()
//  Назначение:    Возвращает разделитель строк таблицы
//  Вход:          нет
//  Выход:         разделитель строк таблицы
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
string CommandLineParser::GetRowDeliver() {return row_deliver;}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::GetDataDeliver()
//  Назначение:    Возвращает разделитель данных таблицы
//  Вход:          нет
//  Выход:         разделитель данных таблицы
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
string CommandLineParser::GetDataDeliver() {return data_deliver;}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::GetTopItDeliver()
//  Назначение:    Возвращает разделитель данных разных таблиц
//  Вход:          нет
//  Выход:         разделитель данных разных таблиц
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
string CommandLineParser::GetTopItDeliver() {return topit_deliver;}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::GetStatus()
//  Назначение:    Возвращает статус разбора
//  Вход:          нет
//  Выход:         статус разбора
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
status_type CommandLineParser::GetStatus() {return status;}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Имя:           CommandLineParser::Help()
//  Назначение:    Выводит помощь по использованию сервера
//  Вход:          нет
//  Выход:         нет
//  Примечание:    
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CommandLineParser::Help()
{
	cout<<"\n|================================================================================|\n";
	cout<<"|| Формат запуска DDE-сервера:                                                  ||\n";
	cout<<"|| DDE_server [параметр1 [значение1]]...[параметрN [значениеN]]                 ||\n";
	cout<<"|================================================================================|\n"; 
	cout<<"|| Допустимые параметры:                                                        ||\n";
	cout<<"|| -h - помощь по использованию DDE-сервера;                                    ||\n";
	cout<<"|| -s - задает имя сервиса (например: DDE_server -s \"MyService\").               ||\n"; 
	cout<<"||      Значение по умолчанию: \"excel\"                                          ||\n";
	cout<<"|| -f - задает разделитель столбцов (например: DDE_server -f \"_ _\").            ||\n"; 
	cout<<"||      Значение по умолчанию: \";\"                                              ||\n";
	cout<<"|| -n - задает разделитель строк (например: DDE_server -n \"new:\").              ||\n"; 
	cout<<"||      Значение по умолчанию: \"\\n\"                                             ||\n";
	cout<<"|| -d - задает разделитель между порциями данных (например: DDE_server -d \"---\".||\n";
	cout<<"||      Значение по умолчанию: \"\" (т.е. нет разделителя)                        ||\n";
	cout<<"|| -t - Если указан, то предписывает перед каждой строчкой выводить             ||\n";
	cout<<"||      имя топика и итема с укаанным разделителем.                             ||\n";
	cout<<"||      Если не указан, то предписывает не выводить имена перед каждой строкой. ||\n";
	cout<<"||      (например: DDE_server -t \"- \").                                         ||\n";
	cout<<"||      Значение по умолчанию: \"\" (т.е. нет разделителя)                        ||\n";
	cout<<"|================================================================================|\n";
}